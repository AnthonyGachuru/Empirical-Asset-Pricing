theta.s = 0
delta2.s = 0.001
gamma = 50
eta = 2
for (i in 2:simulation.length){
# mu and sigma for the merton model
delta.star.2 = 1/(data.length/merton.sigma2.vector[i-1] + 1/delta2)
merton.mu.vector[i] = rnorm(1,(sum(spx_index_values$Return-merton.Z.data*merton.xi.data)/merton.sigma2.vector[i-1]+theta/delta2)*delta.star.2, sqrt(delta.star.2))
merton.sigma2.vector[i] = rigamma(1,alpha+0.5*data.length, beta+0.5*sum((spx_index_values$Return - merton.mu.vector[i] - merton.Z.data*merton.xi.data)^2))
# mu and sigma for the jump size
delta.star.s.2 = 1/(data.length/merton.sigma2.s.vector[i-1] + 1/delta2.s)
merton.mu.s.vector[i] = rnorm(1,(sum(merton.xi.data)/merton.sigma2.vector[i-1]+theta.s/delta2.s)*delta.star.s.2, sqrt(delta.star.s.2))
merton.sigma2.s.vector[i] = rigamma(1,alpha.s+0.5*data.length, beta.s+0.5*sum((merton.xi.data - merton.mu.s.vector[i])^2))
# jump intensity
merton.lambda.vector[i] = rbeta(1, sum(merton.Z.data)+gamma, data.length - sum(merton.Z.data) + eta)
# state variable xi
sigma.star.xi = 1/(merton.Z[i-1]/merton.sigma2.vector[i]+1/merton.sigma2.s.vector[i])
for (j in 1:data.length){
merton.xi.data[j] = rnorm(1, (spx_index_values$Return[j]-merton.mu.vector[i])*merton.Z.data(j)/merton.sigma2.vector[i]+merton.mu.s.vector[i]/merton.sigma2.s.vector[i], sqrt(sigma.star.xi))
jump.ind = runif(1, 0, 1)
if (jump.ind < exp(-0.5*(spx_index_values$Return[j]-merton.mu.vector[i]-merton.xi.data[j])^2/merton.sigma2.vector[i])){
merton.Z.data[j] = 1
}
else{
merton.Z.data[j] = 0
}
}
}
i
delta.star.2 = 1/(data.length/merton.sigma2.vector[i-1] + 1/delta2)
merton.mu.vector[i] = rnorm(1,(sum(spx_index_values$Return-merton.Z.data*merton.xi.data)/merton.sigma2.vector[i-1]+theta/delta2)*delta.star.2, sqrt(delta.star.2))
delta.star.2
1/(data.length/merton.sigma2.vector[i-1] + 1/delta2)
(data.length/merton.sigma2.vector[i-1] + 1/delta2)
merton.sigma2.vector[i-1]
# initialize the parameters (priors)
merton.mu.vector[1] = mean(spx_index_values$Return)
merton.sigma2.vector[1] = var(spx_index_values$Return)
merton.mu.s.vector[1] = 0
merton.sigma2.s.vector[1] = 0.03
merton.lambda.vector[1] = 0.03
merton.Z.data = as.numeric(runif(data.length, 0, 1) < merton.lambda.vector[1])
merton.xi.data = rnorm(data.length, merton.mu.s.vector[1], sqrt(merton.sigma2.s.vector[1]))
merton.Z[1] = 0
merton.xi = 0
alpha = 1000
beta = 0.2
theta = 0
delta2 = 0.001
alpha.s = 1000
beta.s = 0.2
theta.s = 0
delta2.s = 0.001
gamma = 50
eta = 2
for (i in 2:simulation.length){
# mu and sigma for the merton model
delta.star.2 = 1/(data.length/merton.sigma2.vector[i-1] + 1/delta2)
merton.mu.vector[i] = rnorm(1,(sum(spx_index_values$Return-merton.Z.data*merton.xi.data)/merton.sigma2.vector[i-1]+theta/delta2)*delta.star.2, sqrt(delta.star.2))
merton.sigma2.vector[i] = rigamma(1,alpha+0.5*data.length, beta+0.5*sum((spx_index_values$Return - merton.mu.vector[i] - merton.Z.data*merton.xi.data)^2))
# mu and sigma for the jump size
delta.star.s.2 = 1/(data.length/merton.sigma2.s.vector[i-1] + 1/delta2.s)
merton.mu.s.vector[i] = rnorm(1,(sum(merton.xi.data)/merton.sigma2.vector[i-1]+theta.s/delta2.s)*delta.star.s.2, sqrt(delta.star.s.2))
merton.sigma2.s.vector[i] = rigamma(1,alpha.s+0.5*data.length, beta.s+0.5*sum((merton.xi.data - merton.mu.s.vector[i])^2))
# jump intensity
merton.lambda.vector[i] = rbeta(1, sum(merton.Z.data)+gamma, data.length - sum(merton.Z.data) + eta)
# state variable xi
sigma.star.xi = 1/(merton.Z[i-1]/merton.sigma2.vector[i]+1/merton.sigma2.s.vector[i])
for (j in 1:data.length){
merton.xi.data[j] = rnorm(1, (spx_index_values$Return[j]-merton.mu.vector[i])*merton.Z.data(j)/merton.sigma2.vector[i]+merton.mu.s.vector[i]/merton.sigma2.s.vector[i], sqrt(sigma.star.xi))
jump.ind = runif(1, 0, 1)
if (jump.ind < exp(-0.5*(spx_index_values$Return[j]-merton.mu.vector[i]-merton.xi.data[j])^2/merton.sigma2.vector[i])){
merton.Z.data[j] = 1
}
else{
merton.Z.data[j] = 0
}
}
}
i
delta.star.2 = 1/(data.length/merton.sigma2.vector[i-1] + 1/delta2)
merton.mu.vector[i] = rnorm(1,(sum(spx_index_values$Return-merton.Z.data*merton.xi.data)/merton.sigma2.vector[i-1]+theta/delta2)*delta.star.2, sqrt(delta.star.2))
merton.sigma2.vector[i] = rigamma(1,alpha+0.5*data.length, beta+0.5*sum((spx_index_values$Return - merton.mu.vector[i] - merton.Z.data*merton.xi.data)^2))
# mu and sigma for the jump size
delta.star.s.2 = 1/(data.length/merton.sigma2.s.vector[i-1] + 1/delta2.s)
merton.mu.s.vector[i] = rnorm(1,(sum(merton.xi.data)/merton.sigma2.vector[i-1]+theta.s/delta2.s)*delta.star.s.2, sqrt(delta.star.s.2))
merton.sigma2.s.vector[i] = rigamma(1,alpha.s+0.5*data.length, beta.s+0.5*sum((merton.xi.data - merton.mu.s.vector[i])^2))
# jump intensity
merton.lambda.vector[i] = rbeta(1, sum(merton.Z.data)+gamma, data.length - sum(merton.Z.data) + eta)
# state variable xi
sigma.star.xi = 1/(merton.Z[i-1]/merton.sigma2.vector[i]+1/merton.sigma2.s.vector[i])
for (j in 1:data.length){
merton.xi.data[j] = rnorm(1, (spx_index_values$Return[j]-merton.mu.vector[i])*merton.Z.data(j)/merton.sigma2.vector[i]+merton.mu.s.vector[i]/merton.sigma2.s.vector[i], sqrt(sigma.star.xi))
jump.ind = runif(1, 0, 1)
if (jump.ind < exp(-0.5*(spx_index_values$Return[j]-merton.mu.vector[i]-merton.xi.data[j])^2/merton.sigma2.vector[i])){
merton.Z.data[j] = 1
}
else{
merton.Z.data[j] = 0
}
}
}
for (i in 2:simulation.length){
# mu and sigma for the merton model
delta.star.2 = 1/(data.length/merton.sigma2.vector[i-1] + 1/delta2)
merton.mu.vector[i] = rnorm(1,(sum(spx_index_values$Return-merton.Z.data*merton.xi.data)/merton.sigma2.vector[i-1]+theta/delta2)*delta.star.2, sqrt(delta.star.2))
merton.sigma2.vector[i] = rigamma(1,alpha+0.5*data.length, beta+0.5*sum((spx_index_values$Return - merton.mu.vector[i] - merton.Z.data*merton.xi.data)^2))
# mu and sigma for the jump size
delta.star.s.2 = 1/(data.length/merton.sigma2.s.vector[i-1] + 1/delta2.s)
merton.mu.s.vector[i] = rnorm(1,(sum(merton.xi.data)/merton.sigma2.vector[i-1]+theta.s/delta2.s)*delta.star.s.2, sqrt(delta.star.s.2))
merton.sigma2.s.vector[i] = rigamma(1,alpha.s+0.5*data.length, beta.s+0.5*sum((merton.xi.data - merton.mu.s.vector[i])^2))
# jump intensity
merton.lambda.vector[i] = rbeta(1, sum(merton.Z.data)+gamma, data.length - sum(merton.Z.data) + eta)
# state variable xi
sigma.star.xi = 1/(merton.Z[i-1]/merton.sigma2.vector[i]+1/merton.sigma2.s.vector[i])
for (j in 1:data.length){
merton.xi.data[j] = rnorm(1, (spx_index_values$Return[j]-merton.mu.vector[i])*merton.Z.data[j]/merton.sigma2.vector[i]+merton.mu.s.vector[i]/merton.sigma2.s.vector[i], sqrt(sigma.star.xi))
jump.ind = runif(1, 0, 1)
if (jump.ind < exp(-0.5*(spx_index_values$Return[j]-merton.mu.vector[i]-merton.xi.data[j])^2/merton.sigma2.vector[i])){
merton.Z.data[j] = 1
}
else{
merton.Z.data[j] = 0
}
}
}
j
merton.xi.data[j] = rnorm(1, (spx_index_values$Return[j]-merton.mu.vector[i])*merton.Z.data[j]/merton.sigma2.vector[i]+merton.mu.s.vector[i]/merton.sigma2.s.vector[i], sqrt(sigma.star.xi))
sigma.star.xi
merton.Z[i-1]
merton.sigma2.vector[i]
merton.sigma2.s.vector[i]
merton.sigma2.vector[i]
merton.mu.s.vector[i]
delta.star.s.2
(sum(merton.xi.data)/merton.sigma2.vector[i-1]+theta.s/delta2.s)*delta.star.s.2
delta.star.s.2
(sum(merton.xi.data)/merton.sigma2.vector[i-1]+theta.s/delta2.s)
merton.sigma2.vector[i-1]
theta.s/delta2.s
sum(merton.xi.data)/merton.sigma2.vector[i-1]
sum(merton.xi.data)
merton.mu.s.vector[1]
sqrt(merton.sigma2.s.vector[1])
merton.xi.data = rnorm(data.length, merton.mu.s.vector[1], sqrt(merton.sigma2.s.vector[1]))
sum(merton.xi.data)
merton.mu.s.vector[1]
merton.xi.data[j] = rnorm(1, (spx_index_values$Return[j]-merton.mu.vector[i])*merton.Z.data[j]/merton.sigma2.vector[i]+merton.mu.s.vector[i]/merton.sigma2.s.vector[i], sqrt(sigma.star.xi))
delta.star.2 = 1/(data.length/merton.sigma2.vector[i-1] + 1/delta2)
merton.mu.vector[i] = rnorm(1,(sum(spx_index_values$Return-merton.Z.data*merton.xi.data)/merton.sigma2.vector[i-1]+theta/delta2)*delta.star.2, sqrt(delta.star.2))
merton.sigma2.vector[i] = rigamma(1,alpha+0.5*data.length, beta+0.5*sum((spx_index_values$Return - merton.mu.vector[i] - merton.Z.data*merton.xi.data)^2))
merton.mu.s.vector[i] = rnorm(1,(sum(merton.xi.data)/merton.sigma2.vector[i-1]+theta.s/delta2.s)*delta.star.s.2, sqrt(delta.star.s.2))
merton.sigma2.s.vector[i] = rigamma(1,alpha.s+0.5*data.length, beta.s+0.5*sum((merton.xi.data - merton.mu.s.vector[i])^2))
# mu and sigma for the jump size
delta.star.s.2 = 1/(data.length/merton.sigma2.s.vector[i-1] + 1/delta2.s)
delta.star.2 = 1/(data.length/merton.sigma2.vector[i-1] + 1/delta2)
merton.mu.vector[i] = rnorm(1,(sum(spx_index_values$Return-merton.Z.data*merton.xi.data)/merton.sigma2.vector[i-1]+theta/delta2)*delta.star.2, sqrt(delta.star.2))
merton.mu.vector[i] = rnorm(1,(sum(spx_index_values$Return-merton.Z.data*merton.xi.data)/merton.sigma2.vector[i-1]+theta/delta2)*delta.star.2, sqrt(delta.star.2))
(sum(spx_index_values$Return-merton.Z.data*merton.xi.data)/merton.sigma2.vector[i-1]+theta/delta2)*delta.star.2
delta.star.2
(sum(spx_index_values$Return-merton.Z.data*merton.xi.data)/merton.sigma2.vector[i-1]+theta/delta2)
sum(spx_index_values$Return-merton.Z.data*merton.xi.data)/merton.sigma2.vector[i-1]
theta/delta2
merton.sigma2.vector[i-1]
sum(spx_index_values$Return-merton.Z.data*merton.xi.data)
sum(spx_index_values$Return)
sum(merton.Z.data)
sum(merton.xi.data)
merton.Z.data = as.numeric(runif(data.length, 0, 1) < merton.lambda.vector[1])
sum(merton.Z.data)
merton.xi.data = rnorm(data.length, merton.mu.s.vector[1], sqrt(merton.sigma2.s.vector[1]))
sum(merton.xi.data)
for (i in 2:simulation.length){
# mu and sigma for the merton model
delta.star.2 = 1/(data.length/merton.sigma2.vector[i-1] + 1/delta2)
merton.mu.vector[i] = rnorm(1,(sum(spx_index_values$Return-merton.Z.data*merton.xi.data)/merton.sigma2.vector[i-1]+theta/delta2)*delta.star.2, sqrt(delta.star.2))
merton.sigma2.vector[i] = rigamma(1,alpha+0.5*data.length, beta+0.5*sum((spx_index_values$Return - merton.mu.vector[i] - merton.Z.data*merton.xi.data)^2))
# mu and sigma for the jump size
delta.star.s.2 = 1/(data.length/merton.sigma2.s.vector[i-1] + 1/delta2.s)
merton.mu.s.vector[i] = rnorm(1,(sum(merton.xi.data)/merton.sigma2.vector[i-1]+theta.s/delta2.s)*delta.star.s.2, sqrt(delta.star.s.2))
merton.sigma2.s.vector[i] = rigamma(1,alpha.s+0.5*data.length, beta.s+0.5*sum((merton.xi.data - merton.mu.s.vector[i])^2))
# jump intensity
merton.lambda.vector[i] = rbeta(1, sum(merton.Z.data)+gamma, data.length - sum(merton.Z.data) + eta)
# state variable xi
sigma.star.xi = 1/(merton.Z[i-1]/merton.sigma2.vector[i]+1/merton.sigma2.s.vector[i])
for (j in 1:data.length){
merton.xi.data[j] = rnorm(1, (spx_index_values$Return[j]-merton.mu.vector[i])*merton.Z.data[j]/merton.sigma2.vector[i]+merton.mu.s.vector[i]/merton.sigma2.s.vector[i], sqrt(sigma.star.xi))
jump.ind = runif(1, 0, 1)
if (jump.ind < exp(-0.5*(spx_index_values$Return[j]-merton.mu.vector[i]-merton.xi.data[j])^2/merton.sigma2.vector[i])){
merton.Z.data[j] = 1
}
else{
merton.Z.data[j] = 0
}
}
}
i
j
merton.mu.s.vector[i]
merton.mu.s.vector[1:56]
merton.mu.vector[1:56]
merton.Z.data
sum(merton.Z.data)
merton.lambda.vector[1:56]
merton.sigma2.s.vector[1:56]
merton.xi.data
simulation.length = 100
for (i in 2:simulation.length){
# mu and sigma for the merton model
delta.star.2 = 1/(data.length/merton.sigma2.vector[i-1] + 1/delta2)
merton.mu.vector[i] = rnorm(1,(sum(spx_index_values$Return-merton.Z.data*merton.xi.data)/merton.sigma2.vector[i-1]+theta/delta2)*delta.star.2, sqrt(delta.star.2))
merton.sigma2.vector[i] = rigamma(1,alpha+0.5*data.length, beta+0.5*sum((spx_index_values$Return - merton.mu.vector[i] - merton.Z.data*merton.xi.data)^2))
# mu and sigma for the jump size
delta.star.s.2 = 1/(data.length/merton.sigma2.s.vector[i-1] + 1/delta2.s)
merton.mu.s.vector[i] = rnorm(1,(sum(merton.xi.data*merton.Z.data)/merton.sigma2.vector[i-1]+theta.s/delta2.s)*delta.star.s.2, sqrt(delta.star.s.2))
merton.sigma2.s.vector[i] = rigamma(1,alpha.s+0.5*data.length, beta.s+0.5*sum((merton.Z.data*merton.xi.data - merton.mu.s.vector[i])^2))
# jump intensity
merton.lambda.vector[i] = rbeta(1, sum(merton.Z.data)+gamma, data.length - sum(merton.Z.data) + eta)
# state variable xi
sigma.star.xi = 1/(merton.Z[i-1]/merton.sigma2.vector[i]+1/merton.sigma2.s.vector[i])
for (j in 1:data.length){
merton.xi.data[j] = rnorm(1, (spx_index_values$Return[j]-merton.mu.vector[i])*merton.Z.data[j]/merton.sigma2.vector[i]+merton.mu.s.vector[i]/merton.sigma2.s.vector[i], sqrt(sigma.star.xi))
jump.ind = runif(1, 0, 1)
if (jump.ind < exp(-0.5*(spx_index_values$Return[j]-merton.mu.vector[i]-merton.xi.data[j])^2/merton.sigma2.vector[i])){
merton.Z.data[j] = 1
}
else{
merton.Z.data[j] = 0
}
}
}
i
j
merton.mu.vector = rep(0, simulation.length)
merton.sigma2.vector = rep(0, simulation.length)
merton.mu.s.vector = rep(0, simulation.length)
merton.sigma2.s.vector = rep(0, simulation.length)
merton.lambda.vector = rep(0, simulation.length)
merton.Z = rep(0, simulation.length)
merton.xi = rep(0, simulation.length)
# initialize the parameters (priors)
merton.mu.vector[1] = mean(spx_index_values$Return)
merton.sigma2.vector[1] = var(spx_index_values$Return)
merton.mu.s.vector[1] = 0
merton.sigma2.s.vector[1] = 0.03
merton.lambda.vector[1] = 0.03
merton.Z.data = as.numeric(runif(data.length, 0, 1) < merton.lambda.vector[1])
merton.xi.data = rnorm(data.length, merton.mu.s.vector[1], sqrt(merton.sigma2.s.vector[1]))
merton.Z[1] = 0
merton.xi = 0
alpha = 1000
beta = 0.2
theta = 0
delta2 = 0.001
alpha.s = 1000
beta.s = 0.2
theta.s = 0
delta2.s = 0.001
gamma = 50
eta = 2
for (i in 2:simulation.length){
# mu and sigma for the merton model
delta.star.2 = 1/(data.length/merton.sigma2.vector[i-1] + 1/delta2)
merton.mu.vector[i] = rnorm(1,(sum(spx_index_values$Return-merton.Z.data*merton.xi.data)/merton.sigma2.vector[i-1]+theta/delta2)*delta.star.2, sqrt(delta.star.2))
merton.sigma2.vector[i] = rigamma(1,alpha+0.5*data.length, beta+0.5*sum((spx_index_values$Return - merton.mu.vector[i] - merton.Z.data*merton.xi.data)^2))
# mu and sigma for the jump size
delta.star.s.2 = 1/(data.length/merton.sigma2.s.vector[i-1] + 1/delta2.s)
merton.mu.s.vector[i] = rnorm(1,(sum(merton.xi.data*merton.Z.data)/merton.sigma2.vector[i-1]+theta.s/delta2.s)*delta.star.s.2, sqrt(delta.star.s.2))
merton.sigma2.s.vector[i] = rigamma(1,alpha.s+0.5*data.length, beta.s+0.5*sum((merton.Z.data*merton.xi.data - merton.mu.s.vector[i])^2))
# jump intensity
merton.lambda.vector[i] = rbeta(1, sum(merton.Z.data)+gamma, data.length - sum(merton.Z.data) + eta)
# state variable xi
sigma.star.xi = 1/(merton.Z[i-1]/merton.sigma2.vector[i]+1/merton.sigma2.s.vector[i])
for (j in 1:data.length){
merton.xi.data[j] = rnorm(1, (spx_index_values$Return[j]-merton.mu.vector[i])*merton.Z.data[j]/merton.sigma2.vector[i]+merton.mu.s.vector[i]/merton.sigma2.s.vector[i], sqrt(sigma.star.xi))
jump.ind = runif(1, 0, 1)
if (jump.ind < exp(-0.5*(spx_index_values$Return[j]-merton.mu.vector[i]-merton.xi.data[j])^2/merton.sigma2.vector[i])){
merton.Z.data[j] = 1
}
else{
merton.Z.data[j] = 0
}
}
}
simulation.length = 2000
merton.mu.vector = rep(0, simulation.length)
merton.sigma2.vector = rep(0, simulation.length)
merton.mu.s.vector = rep(0, simulation.length)
merton.sigma2.s.vector = rep(0, simulation.length)
merton.lambda.vector = rep(0, simulation.length)
merton.Z = rep(0, simulation.length)
merton.xi = rep(0, simulation.length)
# initialize the parameters (priors)
merton.mu.vector[1] = mean(spx_index_values$Return)
merton.sigma2.vector[1] = var(spx_index_values$Return)
merton.mu.s.vector[1] = 0
merton.sigma2.s.vector[1] = 0.03
merton.lambda.vector[1] = 0.03
merton.Z.data = as.numeric(runif(data.length, 0, 1) < merton.lambda.vector[1])
merton.xi.data = rnorm(data.length, merton.mu.s.vector[1], sqrt(merton.sigma2.s.vector[1]))
merton.Z[1] = 0
merton.xi = 0
alpha = 1000
beta = 0.2
theta = 0
delta2 = 0.001
alpha.s = 1000
beta.s = 0.2
theta.s = 0
delta2.s = 0.001
gamma = 50
eta = 2
for (i in 2:simulation.length){
# mu and sigma for the merton model
delta.star.2 = 1/(data.length/merton.sigma2.vector[i-1] + 1/delta2)
merton.mu.vector[i] = rnorm(1,(sum(spx_index_values$Return-merton.Z.data*merton.xi.data)/merton.sigma2.vector[i-1]+theta/delta2)*delta.star.2, sqrt(delta.star.2))
merton.sigma2.vector[i] = rigamma(1,alpha+0.5*data.length, beta+0.5*sum((spx_index_values$Return - merton.mu.vector[i] - merton.Z.data*merton.xi.data)^2))
# mu and sigma for the jump size
delta.star.s.2 = 1/(data.length/merton.sigma2.s.vector[i-1] + 1/delta2.s)
merton.mu.s.vector[i] = rnorm(1,(sum(merton.xi.data*merton.Z.data)/merton.sigma2.vector[i-1]+theta.s/delta2.s)*delta.star.s.2, sqrt(delta.star.s.2))
merton.sigma2.s.vector[i] = rigamma(1,alpha.s+0.5*data.length, beta.s+0.5*sum((merton.Z.data*merton.xi.data - merton.mu.s.vector[i])^2))
# jump intensity
merton.lambda.vector[i] = rbeta(1, sum(merton.Z.data)+gamma, data.length - sum(merton.Z.data) + eta)
# state variable xi
sigma.star.xi = 1/(merton.Z[i-1]/merton.sigma2.vector[i]+1/merton.sigma2.s.vector[i])
for (j in 1:data.length){
merton.xi.data[j] = rnorm(1, (spx_index_values$Return[j]-merton.mu.vector[i])*merton.Z.data[j]/merton.sigma2.vector[i]+merton.mu.s.vector[i]/merton.sigma2.s.vector[i], sqrt(sigma.star.xi))
jump.ind = runif(1, 0, 1)
if (jump.ind < exp(-0.5*(spx_index_values$Return[j]-merton.mu.vector[i]-merton.xi.data[j])^2/merton.sigma2.vector[i])){
merton.Z.data[j] = 1
}
else{
merton.Z.data[j] = 0
}
}
}
simulation.length = 2000
merton.mu.vector = rep(0, simulation.length)
merton.sigma2.vector = rep(0, simulation.length)
merton.mu.s.vector = rep(0, simulation.length)
merton.sigma2.s.vector = rep(0, simulation.length)
merton.lambda.vector = rep(0, simulation.length)
merton.Z = rep(0, simulation.length)
merton.xi = rep(0, simulation.length)
jump.times = rep(0, simulation.length)
# initialize the parameters (priors)
merton.mu.vector[1] = mean(spx_index_values$Return)
merton.sigma2.vector[1] = var(spx_index_values$Return)
merton.mu.s.vector[1] = 0
merton.sigma2.s.vector[1] = 0.03
merton.lambda.vector[1] = 0.03
merton.Z.data = as.numeric(runif(data.length, 0, 1) < merton.lambda.vector[1])
merton.xi.data = rnorm(data.length, merton.mu.s.vector[1], sqrt(merton.sigma2.s.vector[1]))
merton.Z[1] = 0
merton.xi = 0
alpha = 1000
beta = 0.2
theta = 0
delta2 = 0.001
alpha.s = 1000
beta.s = 0.2
theta.s = 0
delta2.s = 0.001
gamma = 50
eta = 2
for (i in 2:simulation.length){
# mu and sigma for the merton model
delta.star.2 = 1/(data.length/merton.sigma2.vector[i-1] + 1/delta2)
merton.mu.vector[i] = rnorm(1,(sum(spx_index_values$Return-merton.Z.data*merton.xi.data)/merton.sigma2.vector[i-1]+theta/delta2)*delta.star.2, sqrt(delta.star.2))
merton.sigma2.vector[i] = rigamma(1,alpha+0.5*data.length, beta+0.5*sum((spx_index_values$Return - merton.mu.vector[i] - merton.Z.data*merton.xi.data)^2))
# mu and sigma for the jump size
delta.star.s.2 = 1/(data.length/merton.sigma2.s.vector[i-1] + 1/delta2.s)
merton.mu.s.vector[i] = rnorm(1,(sum(merton.xi.data*merton.Z.data)/merton.sigma2.vector[i-1]+theta.s/delta2.s)*delta.star.s.2, sqrt(delta.star.s.2))
merton.sigma2.s.vector[i] = rigamma(1,alpha.s+0.5*data.length, beta.s+0.5*sum((merton.Z.data*merton.xi.data - merton.mu.s.vector[i])^2))
# jump intensity
merton.lambda.vector[i] = rbeta(1, sum(merton.Z.data)+gamma, data.length - sum(merton.Z.data) + eta)
# state variable xi
sigma.star.xi = 1/(merton.Z[i-1]/merton.sigma2.vector[i]+1/merton.sigma2.s.vector[i])
for (j in 1:data.length){
merton.xi.data[j] = rnorm(1, (spx_index_values$Return[j]-merton.mu.vector[i])*merton.Z.data[j]/merton.sigma2.vector[i]+merton.mu.s.vector[i]/merton.sigma2.s.vector[i], sqrt(sigma.star.xi))
jump.ind = runif(1, 0, 1)
if (jump.ind < exp(-0.5*(spx_index_values$Return[j]-merton.mu.vector[i]-merton.xi.data[j])^2/merton.sigma2.vector[i])){
merton.Z.data[j] = 1
}
else{
merton.Z.data[j] = 0
}
}
jump.times[i] = sum(merton.Z.data)
}
jump.times
merton.mu.s.vector
merton.sigma2.s.vector
save.image("D:/Empirical-Asset-Pricing/Assignment 2/merton output.RData")
par(mfrow=c(5,1))
plot(merton.mu.vector, type='l', xlab='mu',xlim=c(1001,2000),main='MCMC estimation for mu')
par(mfrow=c(2,1))
plot(merton.mu.vector, type='l', xlab='mu',xlim=c(1001,2000),main='MCMC estimation for mu')
plot(merton.sigma2.vector, type='l', xlab='sigma^2',xlim=c(1001,2000),main='MCMC estimation for sigma^2')
par(mfrow=c(3,1))
plot(merton.mu.s.vector, type='l', xlab='mu.s',xlim=c(1001,2000),main='MCMC estimation for mu')
plot(merton.sigma2.s.vector, type='l', xlab='sigma.s^2',xlim=c(1001,2000),main='MCMC estimation for sigma^2')
plot(merton.lambda.vector, type='l', xlab='sigma^2',xlim=c(1001,2000),main='MCMC estimation for sigma^2')
plot(merton.mu.vector[1001:2000], type='l', xlab='mu',xlim=c(1001,2000),main='MCMC estimation for mu')
plot(merton.mu.vector, type='l', xlab='mu',main='MCMC estimation for mu')
sum(merton.Z.data)
simulation.length = 2000
merton.mu.vector = rep(0, simulation.length)
merton.sigma2.vector = rep(0, simulation.length)
merton.mu.s.vector = rep(0, simulation.length)
merton.sigma2.s.vector = rep(0, simulation.length)
merton.lambda.vector = rep(0, simulation.length)
merton.Z = rep(0, simulation.length)
merton.xi = rep(0, simulation.length)
jump.times = rep(0, simulation.length)
# initialize the parameters (priors)
merton.mu.vector[1] = mean(spx_index_values$Return)
merton.sigma2.vector[1] = var(spx_index_values$Return)
merton.mu.s.vector[1] = 0
merton.sigma2.s.vector[1] = 0.03
merton.lambda.vector[1] = 0.03
merton.Z.data = as.numeric(runif(data.length, 0, 1) < merton.lambda.vector[1])
merton.xi.data = rnorm(data.length, merton.mu.s.vector[1], sqrt(merton.sigma2.s.vector[1]))
merton.Z[1] = 0
merton.xi = 0
alpha = 1000
beta = 0.2
theta = 0
delta2 = 0.001
alpha.s = 1000
beta.s = 0.2
theta.s = 0
delta2.s = 0.001
gamma = 50
eta = 2
for (i in 2:simulation.length){
# mu and sigma for the merton model
delta.star.2 = 1/(data.length/merton.sigma2.vector[i-1] + 1/delta2)
merton.mu.vector[i] = rnorm(1,(sum(spx_index_values$Return-merton.Z.data*merton.xi.data)/merton.sigma2.vector[i-1]+theta/delta2)*delta.star.2, sqrt(delta.star.2))
merton.sigma2.vector[i] = rigamma(1,alpha+0.5*data.length, beta+0.5*sum((spx_index_values$Return - merton.mu.vector[i] - merton.Z.data*merton.xi.data)^2))
# mu and sigma for the jump size
delta.star.s.2 = 1/(data.length/merton.sigma2.s.vector[i-1] + 1/delta2.s)
merton.mu.s.vector[i] = rnorm(1,(sum(merton.xi.data*merton.Z.data)/merton.sigma2.vector[i-1]+theta.s/delta2.s)*delta.star.s.2, sqrt(delta.star.s.2))
merton.sigma2.s.vector[i] = rigamma(1,alpha.s+0.5*data.length, beta.s+0.5*sum((merton.Z.data*merton.xi.data - merton.mu.s.vector[i])^2))
# jump intensity
merton.lambda.vector[i] = rbeta(1, max(5, min(sum(merton.Z.data), 100))+gamma, data.length - max(5, min(sum(merton.Z.data), 100)) + eta)
# state variable xi
sigma.star.xi = 1/(merton.Z[i-1]/merton.sigma2.vector[i]+1/merton.sigma2.s.vector[i])
for (j in 1:data.length){
merton.xi.data[j] = rnorm(1, (spx_index_values$Return[j]-merton.mu.vector[i])*merton.Z.data[j]/merton.sigma2.vector[i]+merton.mu.s.vector[i]/merton.sigma2.s.vector[i], sqrt(sigma.star.xi))
jump.ind = runif(1, 0, 1)
if (jump.ind < exp(-0.5*(spx_index_values$Return[j]-merton.mu.vector[i]-merton.xi.data[j])^2/merton.sigma2.vector[i])){
merton.Z.data[j] = 1
}
else{
merton.Z.data[j] = 0
}
}
jump.times[i] = sum(merton.Z.data)
}
jump.times
merton.lambda.vector
par(mfrow=c(2,1))
plot(merton.mu.vector, type='l', xlab='mu',xlim=c(1001,2000),main='MCMC estimation for mu')
plot(merton.sigma2.vector, type='l', xlab='sigma^2',xlim=c(1001,2000),main='MCMC estimation for sigma^2')
plot(merton.mu.vector, type='l', xlab='mu',xlim=c(1001,2000),main='MCMC estimation for mu')
plot(merton.sigma2.vector, type='l', xlab='sigma^2',xlim=c(1001,2000), ylim=c(0,2e-04),main='MCMC estimation for sigma^2')
plot(merton.sigma2.vector, type='l', xlab='sigma^2',xlim=c(1001,2000), ylim=c(0,0.0005),main='MCMC estimation for sigma^2')
plot(merton.sigma2.vector, type='l', xlab='sigma^2',xlim=c(1001,2000), ylim=c(0,2e-4),main='MCMC estimation for sigma^2')
plot(merton.sigma2.vector, type='l', xlab='sigma^2',xlim=c(1001,2000), ylim=c(0.0001,0.00015),main='MCMC estimation for sigma^2')
plot(merton.sigma2.vector, type='l', xlab='sigma^2',xlim=c(1001,2000), ylim=c(0.0000,0.00012),main='MCMC estimation for sigma^2')
plot(merton.sigma2.vector, type='l', xlab='sigma^2',xlim=c(1001,2000), ylim=c(0.00006,0.00012),main='MCMC estimation for sigma^2')
plot(merton.sigma2.vector, type='l', xlab='sigma^2',xlim=c(1001,2000), ylim=c(0.00008,0.00012),main='MCMC estimation for sigma^2')
par(mfrow=c(3,1))
plot(merton.mu.s.vector, type='l', xlab='mu.s',xlim=c(1001,2000),main='MCMC estimation for mu')
plot(merton.sigma2.s.vector, type='l', xlab='sigma.s^2',xlim=c(1001,2000),main='MCMC estimation for sigma^2')
plot(merton.lambda.vector, type='l', xlab='sigma^2',xlim=c(1001,2000),main='MCMC estimation for sigma^2')
plot(merton.mu.s.vector, type='l', xlab='mu.s',xlim=c(1001,2000), ylim=c(0.01,0.03),main='MCMC estimation for mu')
plot(merton.mu.s.vector, type='l', xlab='mu.s',xlim=c(1001,2000),main='MCMC estimation for mu')
plot(merton.mu.s.vector, type='l', xlab='mu.s',xlim=c(1001,2000), ylim=c(-0.02,0),main='MCMC estimation for mu')
plot(merton.mu.s.vector, type='l', xlab='mu.s',xlim=c(1001,2000), ylim=c(-0.01,0.01),main='MCMC estimation for mu')
plot(merton.mu.s.vector, type='l', xlab='mu.s',xlim=c(1001,2000), ylim=c(-0.001,0.001),main='MCMC estimation for mu')
plot(merton.mu.s.vector, type='l', xlab='mu.s',xlim=c(1001,2000), ylim=c(-0.003,0.003),main='MCMC estimation for mu')
plot(merton.sigma2.s.vector, type='l', xlab='sigma.s^2',xlim=c(1001,2000),main='MCMC estimation for sigma^2')
plot(merton.sigma2.s.vector, type='l', xlab='sigma.s^2',xlim=c(1001,2000), ylim=c(0,0.0005),main='MCMC estimation for sigma^2')
plot(merton.sigma2.s.vector, type='l', xlab='sigma.s^2',xlim=c(1001,2000), ylim=c(0,0.0002),main='MCMC estimation for sigma^2')
plot(merton.lambda.vector, type='l', xlab='sigma^2',xlim=c(1001,2000),main='MCMC estimation for sigma^2')
par(mfrow=c(3,1))
plot(merton.mu.s.vector, type='l', xlab='mu.s',xlim=c(1001,2000), ylim=c(-0.003,0.003),main='MCMC estimation for mu')
plot(merton.sigma2.s.vector, type='l', xlab='sigma.s^2',xlim=c(1001,2000), ylim=c(0,0.0002),main='MCMC estimation for sigma^2')
plot(merton.lambda.vector, type='l', xlab='sigma^2',xlim=c(1001,2000),main='MCMC estimation for sigma^2')
save.image("D:/Empirical-Asset-Pricing/Assignment 2/merton output.RData")
par(mfrow=c(2,1))
plot(merton.mu.vector, type='l', xlab='mu',xlim=c(1001,2000),main='MCMC estimation for mu')
plot(merton.sigma2.vector, type='l', xlab='sigma^2',xlim=c(1001,2000), ylim=c(0.00008,0.00012),main='MCMC estimation for sigma^2')
par(mfrow=c(2,1))
plot(merton.mu.vector, type='l', xlab='iterations',ylab='mu',xlim=c(1001,2000),main='MCMC estimation Merton model - mu')
plot(merton.sigma2.vector, type='l', xlab='iterations',ylab='sigma^2',xlim=c(1001,2000), ylim=c(0.00008,0.00012),main='MCMC estimation Merton model - sigma^2')
par(mfrow=c(3,1))
plot(merton.mu.s.vector, type='l', xlab='iterations',ylab='mu.s',xlim=c(1001,2000), ylim=c(-0.003,0.003),main='MCMC estimation Merton model - mu.s')
plot(merton.sigma2.s.vector, type='l', xlab='iterations',ylab='sigma.s^2',xlim=c(1001,2000), ylim=c(0,0.0002),main='MCMC estimation Merton model - sigma.s^2')
plot(merton.lambda.vector, type='l', xlab='iterations',ylab='lambda',xlim=c(1001,2000),main='MCMC estimation Merton model - lambda')
merton.mu.vector.est = merton.mu.vector[1001:2000]
merton.sigma2.vector.est = merton.sigma2.vector[1001:2000]
merton.mu.s.vector.est = merton.mu.s.vector[1001:2000]
merton.sigma2.s.vector.est = merton.sigma2.s.vector[1001:2000]
merton.lambda.vector.est = merton.lambda.vector[1001:2000]
quantile.mu.vector = c(quantile(merton.mu.vector.est, 0.025), quantile(merton.mu.vector.est, 0.5), quantile(merton.mu.vector.est, 0.975))
quantile.sigma2.vector = c(quantile(merton.sigma2.vector.est, 0.025), quantile(merton.sigma2.vector.est, 0.5), quantile(merton.sigma2.vector.est, 0.975))
quantile.mu.vector = c(quantile(merton.mu.s.vector.est, 0.025), quantile(merton.mu.s.vector.est, 0.5), quantile(merton.mu.s.vector.est, 0.975))
quantile.sigma2.vector = c(quantile(merton.sigma2.s.vector.est, 0.025), quantile(merton.sigma2.s.vector.est, 0.5), quantile(merton.sigma2.s.vector.est, 0.975))
quantile.lambda.vector = c(quantile(merton.lambda.vector.est, 0.025), quantile(merton.lambda.vector.est, 0.5), quantile(merton.lambda.vector.est, 0.975))
